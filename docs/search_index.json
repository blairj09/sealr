[
["index.html", "1 Introduction 1.1 What is sealr? 1.2 What are authentication and authorization? 1.3 Implementation", " 1 Introduction 1.1 What is sealr? sealr aims to facilitate implementing authentication and authorization for plumber APIs. Plumber is an R package that allows you to quickly generate an API (Application Programming Interface) from your R code. You can read more about plumber on its website and in its docs. 1.2 What are authentication and authorization? Authentication and authorization are two concepts from cybersecurity. “Authentication is the process of determining whether someone or something is, in fact, who or what it declares itself to be. Authentication technology provides access control for systems by checking to see if a user’s credentials match the credentials in a database of authorized users or in a data authentication server.” Source “Authorization is the process of giving someone permission to do or have something.” Source Another, less formal way to define the terms: authentication is about who you are, authorization is about what you’re allowed to do. In either way, you have certainly encountered both authentication and authorization in your online life. Whenever you log in to a service using your username and password, you are authenticating yourself to use the service. When you give a third party app access to your google account, for example to read your calendar, you are authorizing the app to do so. So why would you need authentication or authorization for your API? Here are two use cases that come to mind: you want to deploy your API at your company but do not want to give everyone access to every endpoint. you want to make your API publicly available on the Internet but you still want users to authenticate before they can use your API (e.g. to prohibit abuse of your API). But there might be even more scenarios, depending on your specific use case, company guidelines, security considerations etc. 1.2.1 Authenticating users Authentication flow - coming soon flowchart 1.2.2 Authorizing users 1.3 Implementation 1.3.1 Overview sealr aims to add authentication / authorization strategies to plumber. So far, sealr’ functionality only covers checking incoming requests for correct authentication details. It does not include functions for providing users with credentials in the first place as this is very specific to the use case. However, we provide several examples that are discussed in the relevant subsections of this book. The R scripts can be found on GitHub (MISSING LINK TO EXAMPLES FOLDER!). The primary logic of sealr is based on plumber filters.1 “Plumber filters can be used to define a “pipeline” for handling incoming requests\" (Plumber docs). So if your plumber API receives a request, the request will first be routed through the different filters before it “arrives” at its destination endpoint. The idea of sealr is to use a filter for authentication/authorization. If a request is not properly authenticated / authorized, sealr will immediately return a “401 - Authentication failed.” error from the filter to the user. In this way, an unauthenticated / unauthorized request will not “reach” its destination endpoint and unauthorized/unauthenticated users will not be able to access your API. 1.3.2 authenticate sealr’s main function is the authenticate function. It is supposed to be used within a plumber filter. authenticate takes a is_authed_* function (see below) as input and depending on the output of this “checker” function, takes action: if the request is authenticated / authorized, it forwards to the next plumber handler using plumber::forward. if the request is not authenticated / authorized, it returns to the user, passing forward HTTP status code, description and message from the output of the is_authed_ function. Most often, this will be a “401 - Authentication failed.” error. For example: pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;header&quot;, secret = secret) }) The actions described above that sealr takes are not visible in the high-level code. You can check the source code for authenticate to see the implementation By accepting a function object as argument, authenticate is quite flexible: You can even pass your own is_authed function. See the examples section of ?sealr::authenticate for a simple example. 1.3.3 is_authed functions The functions starting with is_authed provide the actual implementations of the different authentication / authorization strategies that sealr aims to provide. Currently implemented are: is_authed_jwt: implements JSON Web Token verification and checking. is_authed_oauth2_google: implements Google’s OpenID Connect (which is based on OAuth2.0) is_authed_* functions return a list with the following elements: is_authed: TRUE or FALSE. Result of the check whether the request is authenticated / authorized. status: character. Optional (typically only set if is_authed is FALSE). Short description of HTTP status code. code: integer. Optional (typically only set if is_authed is FALSE). HTTP status code. message: character. Optional (typically only set if is_authed is FALSE). Longer description. Usage of the is_authed functions is not restricted to plumber filters. For example, you can use an is_authed function at the top of an endpoint to restrict access to certain endpoints or use different authorization “levels” for different endpoints. This is particularly relevant if you have more than two “levels” of authorization (see the claims example). Though, you can use sealr functionality without filters as well by using the is_authed functions directly.↩ "],
["02_auth_strategies.html", "2 Strategies 2.1 JSON Web Tokens (JWT) 2.2 Open ID Connect - Google", " 2 Strategies 2.1 JSON Web Tokens (JWT) 2.1.1 Introduction “JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.” (jwt.io) The JWT stratgey allows to use JSON Web Tokens (JWT) to secure your plumber endpoints. A great introduction to JWT can be found here. JWT can be used to secure REST APIs without sessions. They are considered to be stateless although they can also be used as stateful session tokens. JSON Web Tokens (JWT) can contain claims. “Claims are statements about an entity (typically, the user) and additional data” (https://jwt.io/introduction/). They are expressed as key-value pairs. There are three different types of claims: registered, public and private claims. All types of claims are implemented in the same manner, they only differ in whether and where the claims are registered with the Internet Assigned Numbers Authority (IANA). For example, the iss claim is a registered claim defined in the JWT standard RFC 7519 and registered at IANA. See the JWT Introduction of jwt.io for more details. sealr allows you to check for the validity of all types of claims in a given JWT using the claims argument of the sealr::is_authed_jwt function. 2.1.2 Simple Example In the code below, you find a small example of how to implement a JWT strategy in an application. The application consists of three routes. The first route allows your users to login and issues a JWT. The second route is an open route that does not require authentication. The third route requires authentication using the JWT. The JWT filter looks like this: # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;header&quot;, secret = secret) }) :warning: Please change the secret to a super secure secret of your choice. Please notice that you have to preempt = c(\"sealr-jwt\") to routes that should not be protected. 2.1.2.1 Run the example Copy the code from below in a new R file and save it under jwt_simple_example.R. In the R console, run: plumber::plumb(&quot;jwt_simple_example.R&quot;) This will make the API available at localhost:9090. In order to run this example, you need the following packages installed: sealr plumber httr jose jsonlite 2.1.2.2 Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame). id user password 1 jane@example.com $2a\\(12\\)zCLOP45IiXEQ69YUE9fiw.ajr.xb1VKiYoWkQcINzbod80f7CGFVi 2 bob@example.com $2a\\(12\\)Oel5qHEjWaNdDE.3RJzgBeBiEzes3U01Yfa1QaY5ThxjpaqdKT/f2 For example, in curl: curl --data &#39;{&quot;user&quot;: &quot;jane@example.com&quot;, &quot;password&quot;: &quot;12345&quot;}&#39; localhost:9090/authentication gives back the JWT: [&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1NTE0NDk5NTcsInVzZXJJRCI6MX0.0563N-dcz9zY-NF9DQpUnHIONZRWmZU1rb894xxHcNU&quot;] Note: You might get different JWTs as jose::jwt_encode_hmac automatically adds the time when the JWT was issued as a claim (iat claim). However, those examples should still work because we do not add an expiration time to the token - something you should definetely consider for production use cases. Trying to authenticate with a user that is not in the database fails: curl --data &#39;{&quot;user&quot;: &quot;drake@example.com&quot;, &quot;password&quot;: &quot;10111213&quot;}&#39; localhost:9090/authentication {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;User or password wrong.&quot;]} 2.1.2.3 Route without required authentication Everyone can access the / route because it does not require authentication - the sealr-jwt filter is preempted for this route: curl localhost:9090 [&quot;Access to route without authentication was successful.&quot;] 2.1.2.4 Route with authentication Trying to access the /secret route without a JWT fails because it goes through the sealr-jwt filter where the sealr::jwt function will check for the correct authentication details - in this case a valid JWT in the Authorization header. curl localhost:9090/secret {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;Authentication required.&quot;]} Use the JWT obtained with the first curl command to make an authenticated request to this route. curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1NTE0NDk5NTcsInVzZXJJRCI6MX0.0563N-dcz9zY-NF9DQpUnHIONZRWmZU1rb894xxHcNU&quot; localhost:9090/secret [&quot;Access to route requiring authentication was successful.&quot;] 2.1.2.5 Code # define a user database # you should probably use a SQL database instead of data frames users &lt;- data.frame(id = integer(), name = character(), password = character(), stringsAsFactors = FALSE) # create test user users &lt;- rbind(users, data.frame(id = 1, user = &quot;jane@example.com&quot;, password = bcrypt::hashpw(&quot;12345&quot;), stringsAsFactors = FALSE)) users &lt;- rbind(users, data.frame(id = 2, user = &quot;bob@example.com&quot;, password = bcrypt::hashpw(&quot;45678&quot;), stringsAsFactors = FALSE)) # define a new plumber router pr &lt;- plumber::plumber$new() # define your super secret secret &lt;- &quot;3ec9aaf4a744f833e98c954365892583&quot; # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;header&quot;, secret = secret) }) # define authentication route to issue web tokens (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status &lt;- 404 return(list(status=&quot;Failed.&quot;, code=404, message=&quot;Please return password or username.&quot;)) } # find user in database index &lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload &lt;- jose::jwt_claim(userID = users$id[index]) # convert secret to bytes secret_raw &lt;- charToRaw(secret) # encode token using the secret jwt &lt;- jose::jwt_encode_hmac(payload, secret = secret_raw) # return jwt as response return(jwt = jwt) }, preempt = c(&quot;sealr-jwt&quot;)) # define test route without authentication (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;GET&quot;, &quot;/&quot;, function (req, res) { return(&quot;Access to route without authentication was successful.&quot;) }, preempt = c(&quot;sealr-jwt&quot;)) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret&quot;, function (req, res) { return(&quot;Access to route requiring authentication was successful.&quot;) }) # start API server pr$run(host = &quot;0.0.0.0&quot;, port = 9090) 2.1.3 Claims Example In this example implementation (see full code below), we have two filters: The filter sealr-jwt simply checks whether the user is authenticated and that the issuer claim iss is set to mygreatplumberapi, the value we set in the authentication route. The second filter sealr-jwt-admin-only additionally checks whether the user is an admin by validating that the claim admin is TRUE. # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;)) }) pr$filter(&quot;sealr-jwt-admin-only&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;, admin = TRUE)) }) We now have two levels of access using filters: routes that are open to all authenticated users with a JWT issued by mygreatplumberapi and routes that are accessible to admins only. The former requires preempting the more restrictive sealr-jwt-admin-only filter. Unfortunately, it is currently not possible to extend this filter-based authorization mechanism to more than two authorization “levels” because plumber does not allow for preempting more than one filter per route. This problem is on the radar of the plumber team and they’ll provide the opportunity to impose filters on specific endpoints in the future (kind of “reverting” the preempt logic). See this plumber issue. As a workaround, you could put your authentication / authorization checks in the individual endpoints. In this case, use is_authed_* functions instead of the authenticate wrapper. 2.1.3.1 Run the example Copy the code from below in a new R file and save it under jwt_claims_example.R. In the R console, run: plumber::plumb(&quot;jwt_claims_example.R&quot;) This will make the API available at localhost:9090. In order to run this example, you need the following packages installed: sealr plumber httr jose jsonlite 2.1.3.2 Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame). id user password admin gender 1 jane@example.com $2a\\(12\\)kPNg3YYBn5U90v03JzyEMe4d4YY44npxJbpz52C2hp9j.YddgQMKS TRUE woman 2 bob@example.com $2a\\(12\\)s4d8dBEETHEXKj0HpRkoWex6MiwBoWv0NGMRzF1BTuTogC2IcNvXy FALSE man Get the JWT for both users: Jane curl --data &#39;{&quot;user&quot;: &quot;jane@example.com&quot;, &quot;password&quot;: &quot;12345&quot;}&#39; localhost:9090/authentication [&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NjE0NiwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.AZqJFuXZkjwKbnULHfJVmBapFhZpBgLIUuX7HOJAUhU&quot;] Bob curl --data &#39;{&quot;user&quot;: &quot;bob@example.com&quot;, &quot;password&quot;: &quot;45678&quot;}&#39; localhost:9090/authentication [&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s&quot;] Note: You might get different JWTs as we also add the time when the token was issued as a claim (iat). However, those examples should still work because we do not add an expiration time to the token - something you should definetely consider for production use cases. 2.1.3.3 Route with simple authentication Both users can access the /secret route because they both have valid JWT issued by mygreatplumberapi. The route preempts the more restrictive sealr-jwt-admin-only filter so even non-admin Bob has access. Jane curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE&quot; localhost:9090/secret [&quot;Access to route that requires authentication was successful.&quot;] Bob curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s&quot; localhost:9090/secret [&quot;Access to route that requires authentication was successful.&quot;] 2.1.3.4 Route with admin-only authorization In contrast, only Jane can access the /secret-admin-only route. Jane curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE&quot; localhost:9090/secret-admin-only [&quot;Access to route that requires admin authorization was successful.&quot;] Bob curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s&quot; localhost:9090/secret-admin-only {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;Authentication required.&quot;]} 2.1.3.5 Code # define a user database # you should probably use a SQL database instead of data frames users &lt;- data.frame(id = integer(), name = character(), password = character(), admin = logical(), gender = character(), stringsAsFactors = FALSE) # create test user users &lt;- rbind(users, data.frame(id = 1, user = &quot;jane@example.com&quot;, password = bcrypt::hashpw(&quot;12345&quot;), admin = TRUE, gender = &quot;woman&quot;, stringsAsFactors = FALSE)) users &lt;- rbind(users, data.frame(id = 2, user = &quot;bob@example.com&quot;, password = bcrypt::hashpw(&quot;45678&quot;), admin = FALSE, gender = &quot;man&quot;, stringsAsFactors = FALSE)) # define a new plumber router pr &lt;- plumber::plumber$new() # define your super secret secret &lt;- &quot;3ec9aaf4a744f833e98c954365892583&quot; # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;)) }) # filter that checks whether the user is an admin pr$filter(&quot;sealr-jwt-admin-only&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;, admin = TRUE)) }) # define authentication route to issue web tokens (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status &lt;- 404 return(list(status=&quot;Failed.&quot;, code=404, message=&quot;Please specify password or username.&quot;)) } # find user in database index &lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload &lt;- jose::jwt_claim(iss = &quot;mygreatplumberapi&quot;, # registered claim iat = as.numeric(Sys.time()), # registered claim admin = users$admin[index], gender = users$gender[index], # a public claim userID = users$id[index]) # private claim # convert secret to bytes secret &lt;- charToRaw(secret) # encode token using the secret jwt &lt;- jose::jwt_encode_hmac(payload, secret = secret) # return jwt as response return(jwt = jwt) }, preempt = c(&quot;sealr-jwt&quot;)) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret&quot;, function (req, res) { return(&quot;Access to route that requires authentication was successful.&quot;) }, preempt = &quot;sealr-jwt-admin-only&quot;) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret-admin-only&quot;, function (req, res) { return(&quot;Access to route that requires admin authorization was successful.&quot;) }) # start API server pr$run(host = &quot;0.0.0.0&quot;, port = 9090) 2.2 Open ID Connect - Google 2.2.1 Introduction The Google OAuth2 strategy allows you to use Google’s OpenID Connect interface to authenticate and authorize your users. A detailed introduction and best practices can be found here. The interface uses JWTs. Hence, the process can be considered stateless. Addtionally, the user tokens can be used to access Google APIs. 2.2.2 Example 2.2.2.1 Obtain Google OAuth credentials In order to run this example, you need to obtain OAuth2.0 credentials for your plumber API so that Google later knows that it is authenticating the user to a legitimate application. For this, create a new project in the Google API Console - you may need to authorize your Google account first if you are not yet a user of Google’s developer platform. Once you have created your project, follow the instructions on “Obtain OAuth 2.0 credentials” here. When you have to select the application type, select “Other”. Store the client ID and the client secret as environment variables in your R session using the following commands. Sys.setenv(&quot;GOOGLE_CLIENT_ID&quot; = &quot;yourid&quot;) Sys.setenv(&quot;GOOGLE_CLIENT_SECRET&quot; = &quot;yoursecret&quot;) This will make the client and secret available for your current R session. If you want to make them available beyond your current session, use usethis::edit_r_environ and add them in the file that opens like this: GOOGLE_CLIENT_ID=&quot;yourid&quot; GOOGLE_CLIENT_SECRET=&quot;yoursecret&quot; Save and close the file. 2.2.2.2 Run the plumber API Copy the code from below in a new R file and save it under oauth2_google_simple_example.R. In the R console, run: plumber::plumb(&quot;oauth2_google_simple_example.R&quot;) This will make the API available at localhost:9090. In order to run this example, you need the following packages installed: sealr plumber httr jose jsonlite 2.2.2.3 Authenticate yourself to the plumber API Open your browser and enter http://localhost:9090/authentication/ in the address bar. You’ll be redirected to Google. Authorize your application / plumber API. You’ll be again redirected to a JSON response that, depending on your browser, should look something like this (tokens are blacked out): google return It contains: access_token: the token you would need if you wanted to access any of Google’s APIs in your plumber API. If you only use Google to authenticate users, this will not be necessary. expires_in: how long the access token is valid in seconds. This value is set by Google. In this case, the access token is valid for one hour. refresh_token: the token you can could to refresh your access token. We have not implemented the refresh logic in this example though. scope: the scope your plumber API requested to authorize from the user. In this example, we only requested the “userinfo.profile” scope. token_type: type of token. This will always be “Bearer”. Prepend this to your HTTP Authorization Header (see below). id_token: The ID token. A JSON Web Token (see section on JWT) that contains information about the identify of the user. This token is signed by Google. This is the token you send in the HTTP Authorization header (see below). See also the explanation of the return values on Google’s OpenID Connect website. 2.2.2.4 Send an authenticated request Open a terminal and enter the following command, replacing the YOUR_ID_TOKEN with the id_token from your response. curl -H &quot;Authorization: Bearer YOUR_ID_TOKEN&quot; localhost:9090/secret The ID token will be quite long, so maybe first edit this command in your text editor of choice before copying it to the terminal. Hit enter. You should get back: {&quot;message&quot;:[&quot;Successfully accessed the secret endpoint.&quot;]} 2.2.2.5 Code # define contant variables CLIENT_ID &lt;- Sys.getenv(&quot;GOOGLE_CLIENT_ID&quot;) CLIENT_SECRET &lt;- Sys.getenv(&quot;GOOGLE_CLIENT_SECRET&quot;) # get the discovery document with the required URLs response &lt;- httr::GET(&quot;https://accounts.google.com/.well-known/openid-configuration&quot;) discovery_document &lt;- jsonlite::fromJSON(httr::content(response, type = &quot;text&quot;, encoding = &quot;UTF-8&quot;)) # define a new plumber router pr &lt;- plumber::plumber$new() # integrate the google strategy in a filter pr$filter(&quot;sealr-oauth2-google&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, token_location = &quot;header&quot;, is_authed_fun = sealr::is_authed_oauth2_google, client_id = CLIENT_ID) }) # define authentication route to issue web tokens (exclude &quot;sealr-google&quot; filter using preempt) pr$handle(&quot;GET&quot;, &quot;/authentication&quot;, function (req, res) { url &lt;- discovery_document$authorization_endpoint query &lt;- list(client_id = CLIENT_ID, redirect_uri = &quot;http://localhost:9090/authentication/redirect&quot;, scope = &quot;https://www.googleapis.com/auth/userinfo.profile&quot;, response_type = &quot;code&quot;) auth_url &lt;- httr::parse_url(url = url) auth_url$query &lt;- query auth_url &lt;- httr::build_url(auth_url) res$status &lt;- 301 res$setHeader(&quot;Location&quot;, auth_url) return() }, preempt = c(&quot;sealr-oauth2-google&quot;)) # define authentication route to issue web tokens (exclude &quot;sealr-google&quot; filter using preempt) pr$handle(&quot;GET&quot;, &quot;/authentication/redirect&quot;, function (req, res, code = NULL, error = NULL) { token_url &lt;- discovery_document$token_endpoint body &lt;- list( code = code, client_id = CLIENT_ID, client_secret = CLIENT_SECRET, redirect_uri = &quot;http://localhost:9090/authentication/redirect&quot;, grant_type = &quot;authorization_code&quot; ) response &lt;- httr::POST(token_url, body = body) parsed_response &lt;- jsonlite::fromJSON(httr::content(response, type = &quot;text&quot;)) return(parsed_response) }, preempt = c(&quot;sealr-oauth2-google&quot;)) # protected path pr$handle(&quot;GET&quot;, &quot;/secret&quot;, function (req, res) { list(message = &quot;Successfully accessed the secret endpoint.&quot;) }) # start API server pr$run(host=&quot;0.0.0.0&quot;, port=9090) "],
["03_storage.html", "3 Exchanging and storing tokens 3.1 Exchanging tokens 3.2 Local Storage 3.3 Cookie", " 3 Exchanging and storing tokens The token you provide to the user needs to be stored on their machine so that they can later send it back in the request to your plumber API. Where and how the token is stored depends on your use case and what the service making the requests to your API looks like. 3.1 Exchanging tokens 3.1.1 Issueing the token When you first issue a token to the user - i.e. in the authentication endpoint of our examples - , you have two options how you want to return it to them: send it as part of the HTTP response or set a token in the browser of the user. 3.1.1.1 Return in HTTP response Return the token in the HTTP response by including the appropriate return statement at the end of your authentication endpoint. pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # ... # CODE HERE # ... # return jwt as response return(jwt = jwt) }, preempt = c(&quot;sealr-jwt&quot;)) This is the most flexible way as it allows the user to handle the token according to their needs. They could… … store the token somewhere and later include it in an R script or R Markdown. For example, if the user wants to generate reports and needs to use your API in order to do this. They should take care to follow guidelines on how to securely manage credentials and never include the token in their scripts. … store the token in their web browser’s local storage. The local storage of a web browser is. This is relevant if the user makes the request from a web application from their browser (see . The implementation of the storing mechanism would be part of the frontend code. All frontend oriented languages support storing 3.1.2 Cookie 3.1.3 HTTP Authorization header 3.1.4 Interactive R session If your users simply use the token to make requests from an R script, e.g. by executing an .R file or generating an R markdown file, they should store their token in a secure way. Some resources to get started: - https://db.rstudio.com/best-practices/managing-credentials/ 3.1.5 Another application Another service 3.1.6 Web application Finally, you could have a “typical” web frontend-backend infrastructure where you want to use plumber to serve data to a frontend that your user can visit in their Internet browser. Typically, in web development, there are two approaches to storing user data. 3.2 Local Storage 3.3 Cookie Instead of requiring the user to send the JWT back in the HTTP Authorization header, you can also use a cookie in the browser of the API user to store the JWT. This way, the user does not have to remember to send the JWT in the Authorization header. Instead of requiring the user to send the JWT back in the HTTP Authorization header, you can also use a cookie in the browser of the API user to store the JWT. This way, the user does not have to remember to send the JWT in the Authorization header. 3.3.1 Cookie example In this example, we use an encrypted cookie to store the JWT. You can find the full code for this example at the end of this page. In order to do this, we register an encrypted session cookie (see plumber docs): # define a new plumber router pr &lt;- plumber::plumber$new() # register cookie pr$registerHooks(plumber::sessionCookie(key = &quot;EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5&quot;, name = &quot;token&quot;)) In the authentication route, we then can set the JWT in the cookie. Note that we do not return the JWT to the user because the JWT will be transferred in the cookie instead. pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # ... # ... # set cookie req$session$token &lt;- jwt return() }) The filter looks the same as in the simple example except that we have to change the token_location parameter to \"cookie\" instead of \"header\". # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response # please change the secret sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;cookie&quot;, secret = secret) }) :warning: Please change the secret to a super secure secret of your choice. Please notice that you have to preempt = c(\"sealr-jwt\") to routes that should not be protected. Run the example Copy the code from below in a new R file and save it under jwt_cookie_example.R. In the R console, run: plumber::plumb(&quot;jwt_cookie_example.R&quot;) In order to run this example, you need the following packages installed: sealr plumber httr jose jsonlite Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame). id user password 1 jane@example.com $2a\\(12\\)AhK7o9f0cIGhdwDviZXB1.PqC0/JPaoYGVQCZbdJxWHMXMfpCk.M. 2 bob@example.com $2a\\(12\\)TR97lUBSWreesL0AyIFzveyXOOPLQ8x6qJxMFTOUvVBbHG1U.oipi For example, in curl: Note: You might get different encrypted JWTs in your cookies_jane.txt as jose::jwt_encode_hmac automatically adds the time when the JWT was issued as a claim (iat claim). curl --cookie-jar cookies_jane.txt --data &#39;{&quot;user&quot;: &quot;jane@example.com&quot;, &quot;password&quot;: &quot;12345&quot;}&#39; localhost:9090/authentication The --cookie-jar argument will store the cookie in a plain-text file in your current directory called cookies_jane.txt. If you inspect this file (e.g. using cat cookies_jane.txt), you should see something like this: # Netscape HTTP Cookie File # https://curl.haxx.se/docs/http-cookies.html # This file was generated by libcurl! Edit at your own risk. localhost FALSE / FALSE 0 token R/cOKStnaCrwojcbL4Uk1602scv7ln9PClDYO2LlfHd0zYtd+vYrGB6oTX7wvpp5hmipFxqnQ0FDwEdz1H7IjCr6KCxxUHnpWu8r0IjCA4zLHbJz/i5npGe16Ei+OhbOGbluT/An+0GnfzXsna4q4vHoB2P+GkUPZL3Xe7tZxIX+UHSk005tX89NcSLpVy6J The token is the gibberish part at the end. It is indeed the JWT but it is encrypted and hence does not look like a JWT. Trying to get a token cookie for a user that is not in the database of course fails: curl --cookie-jar cookies_drake.txt --data &#39;{&quot;user&quot;: &quot;drake@example.com&quot;, &quot;password&quot;: &quot;10111213&quot;}&#39; localhost:9090/authentication {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;User or password wrong.&quot;]} Route without required authentication Everyone can access the / route because it does not require authentication - the sealr-jwt filter is preempted for this route: curl localhost:9090 [&quot;Access to route without authentication was successful.&quot;] Route with required authentication Trying to access the /secret route without a valid cookie fails because it goes through the sealr-jwt filter where the sealr::jwt function will check for the correct authentication details - in this case a valid JWT in token cookie. curl localhost:9090/secret {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;Authentication required.&quot;]} But if you add the cookies for Jane to the request, authentication is successful. curl --cookie cookies_jane.txt localhost:9090/secret [&quot;Access to route requiring authentication was successful.&quot;] Code {code} # define a user database # you should probably use a SQL database instead of data frames users &lt;- data.frame(id = integer(), name = character(), password = character(), stringsAsFactors = FALSE) # create test user users &lt;- rbind(users, data.frame(id = 1, user = &quot;jane@example.com&quot;, password = bcrypt::hashpw(&quot;12345&quot;), stringsAsFactors = FALSE)) users &lt;- rbind(users, data.frame(id = 2, user = &quot;bob@example.com&quot;, password = bcrypt::hashpw(&quot;45678&quot;), stringsAsFactors = FALSE)) # define a new plumber router pr &lt;- plumber::plumber$new() # register cookie pr$registerHooks(plumber::sessionCookie(key = &quot;EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5&quot;, name = &quot;token&quot;)) # define your super secret for hmac secret &lt;- &quot;3ec9aaf4a744f833e98c954365892583&quot; # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;cookie&quot;, secret = secret) }) # define authentication route to issue web tokens (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status &lt;- 404 return(list(status=&quot;Failed.&quot;, code=404, message=&quot;Please return password or username.&quot;)) } # find user in database index &lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload &lt;- jose::jwt_claim(userID = users$id[index]) # convert secret to bytes secret_raw &lt;- charToRaw(secret) # encode token using the secret jwt &lt;- jose::jwt_encode_hmac(payload, secret = secret_raw) # set cookie req$session$token &lt;- jwt return() }, preempt = c(&quot;sealr-jwt&quot;)) # define test route without authentication (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;GET&quot;, &quot;/&quot;, function (req, res) { return(&quot;Access to route without authentication was successful.&quot;) }, preempt = c(&quot;sealr-jwt&quot;)) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret&quot;, function (req, res) { return(&quot;Access to route requiring authentication was successful.&quot;) }) # start API server pr$run(host = &quot;0.0.0.0&quot;, port = 9090) "],
["04_security.html", "4 Security 4.1 HTTPS 4.2 Cookies and CSRF 4.3 Local storage and XSS", " 4 Security When developing a plumber API, some considerations regarding security must be made. Many things are already covered in the excellent Security section of the plumber docs, so we mostly link to the respective subsections and add specifics related to authentication/authorization. 4.1 HTTPS Using HTTPS instead of the insecure HTTP is crucial when working with authentication. The data exchanged between your plumber API and the (frontend) application is highly sensitive. If you don’t use https, those data will be sent across the network unencrypted and attackers could easily steal access tokens not only for your plumber API but also tokens exchanged as part of the OAuth dance used for authenticating using Google. Read more about why using HTTPS is critical in the plumber docs. There you also learn more about how you can enable HTTPS for your plumber API. All our examples assume that you use HTTPS. 4.2 Cookies and CSRF 4.3 Local storage and XSS "]
]
