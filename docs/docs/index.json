[
{
	"uri": "https://jandix.github.io/sealr/jwt/jwt_simple_example/",
	"title": "JWT Simple Example",
	"tags": [],
	"description": "",
	"content": " In the code below, you find a small example of how to implement a JWT strategy in an application.\nThe application consists of three routes. The first route allows your users to login and issues a JWT. The second route is an open route that does not require authentication. The third route requires authentication using the JWT.\nThe JWT filter looks like this:\n# integrate the jwt strategy in a filter pr$filter(\u0026quot;sealr-jwt\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = \u0026quot;header\u0026quot;, secret = secret) })  :warning: Please change the secret to a super secure secret of your choice. Please notice that you have to preempt = c(\u0026quot;sealr-jwt\u0026quot;) to routes that should not be protected.\nRun the example Copy the code from below in a new R file and save it under jwt_simple_example.R. In the R console, run:\nplumber::plumb(\u0026quot;jwt_simple_example.R\u0026quot;)  This will make the API available at localhost:9090.\nIn order to run this example, you need the following packages installed:\n sealr plumber httr jose jsonlite  Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame).\n    id user password    1 jane@example.com $2a12ivbTpArLsmj9yEadAkSO8enoHLRNyEvnGcogV/SLFXmvaqBYqe2Xu  2 bob@example.com $2a12GMcha6QyvuzuLMOF4HRXCu9I5OcZRiloLEDy8U7NafXW46F2I1lfy    For example, in curl:\ncurl --data '{\u0026quot;user\u0026quot;: \u0026quot;jane@example.com\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;12345\u0026quot;}' localhost:9090/authentication  gives back the JWT:\n[\u0026quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1NTE0NDk5NTcsInVzZXJJRCI6MX0.0563N-dcz9zY-NF9DQpUnHIONZRWmZU1rb894xxHcNU\u0026quot;]  Note: You might get different JWTs as jose::jwt_encode_hmac automatically adds the time when the JWT was issued as a claim (iat claim). However, those examples should still work because we do not add an expiration time to the token - something you should definetely consider for production use cases.\nTrying to authenticate with a user that is not in the database fails:\ncurl --data '{\u0026quot;user\u0026quot;: \u0026quot;drake@example.com\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;10111213\u0026quot;}' localhost:9090/authentication {\u0026quot;status\u0026quot;:[\u0026quot;Failed.\u0026quot;],\u0026quot;code\u0026quot;:[401],\u0026quot;message\u0026quot;:[\u0026quot;User or password wrong.\u0026quot;]}  Route without required authentication Everyone can access the / route because it does not require authentication - the sealr-jwt filter is preempted for this route:\ncurl localhost:9090 [\u0026quot;Access to route without authentication was successful.\u0026quot;]  Route with authentication Trying to access the /secret route without a JWT fails because it goes through the sealr-jwt filter where the sealr::jwt function will check for the correct authentication details - in this case a valid JWT in the Authorization header.\ncurl localhost:9090/secret {\u0026quot;status\u0026quot;:[\u0026quot;Failed.\u0026quot;],\u0026quot;code\u0026quot;:[401],\u0026quot;message\u0026quot;:[\u0026quot;Authentication required.\u0026quot;]}  Use the JWT obtained with the first curl command to make an authenticated request to this route.\ncurl -H \u0026quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1NTE0NDk5NTcsInVzZXJJRCI6MX0.0563N-dcz9zY-NF9DQpUnHIONZRWmZU1rb894xxHcNU\u0026quot; localhost:9090/secret [\u0026quot;Access to route requiring authentication was successful.\u0026quot;]  Code # define a user database # you should probably use a SQL database instead of data frames users \u0026lt;- data.frame(id = integer(), name = character(), password = character(), stringsAsFactors = FALSE) # create test user users \u0026lt;- rbind(users, data.frame(id = 1, user = \u0026quot;jane@example.com\u0026quot;, password = bcrypt::hashpw(\u0026quot;12345\u0026quot;), stringsAsFactors = FALSE)) users \u0026lt;- rbind(users, data.frame(id = 2, user = \u0026quot;bob@example.com\u0026quot;, password = bcrypt::hashpw(\u0026quot;45678\u0026quot;), stringsAsFactors = FALSE)) # define a new plumber router pr \u0026lt;- plumber::plumber$new() # define your super secret secret \u0026lt;- \u0026quot;3ec9aaf4a744f833e98c954365892583\u0026quot; # integrate the jwt strategy in a filter pr$filter(\u0026quot;sealr-jwt\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = \u0026quot;header\u0026quot;, secret = secret) }) # define authentication route to issue web tokens (exclude \u0026quot;sealr-jwt\u0026quot; filter using preempt) pr$handle(\u0026quot;POST\u0026quot;, \u0026quot;/authentication\u0026quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status \u0026lt;- 404 return(list(status=\u0026quot;Failed.\u0026quot;, code=404, message=\u0026quot;Please return password or username.\u0026quot;)) } # find user in database index \u0026lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status \u0026lt;- 401 return(list(status=\u0026quot;Failed.\u0026quot;, code=401, message=\u0026quot;User or password wrong.\u0026quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status \u0026lt;- 401 return(list(status=\u0026quot;Failed.\u0026quot;, code=401, message=\u0026quot;User or password wrong.\u0026quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload \u0026lt;- jose::jwt_claim(userID = users$id[index]) # convert secret to bytes secret_raw \u0026lt;- charToRaw(secret) # encode token using the secret jwt \u0026lt;- jose::jwt_encode_hmac(payload, secret = secret_raw) # return jwt as response return(jwt = jwt) }, preempt = c(\u0026quot;sealr-jwt\u0026quot;)) # define test route without authentication (exclude \u0026quot;sealr-jwt\u0026quot; filter using preempt) pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/\u0026quot;, function (req, res) { return(\u0026quot;Access to route without authentication was successful.\u0026quot;) }, preempt = c(\u0026quot;sealr-jwt\u0026quot;)) # define test route with authentication pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/secret\u0026quot;, function (req, res) { return(\u0026quot;Access to route requiring authentication was successful.\u0026quot;) }) # start API server pr$run(host = \u0026quot;0.0.0.0\u0026quot;, port = 9090)  "
},
{
	"uri": "https://jandix.github.io/sealr/oauth_google/oauth2_google_simple_example/",
	"title": "OAuth2 Google Simple Example",
	"tags": [],
	"description": "",
	"content": " Install the packages Install the following packages if you haven’t already:\n sealr httr jose jsonlite  define a new plumber router pr \u0026lt;- plumber::plumber$new() pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/\u0026quot;, function (req, res, code = NULL) { })  define authentication route to issue web tokens (exclude “sealr-jwt” filter using preempt) pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/authentication\u0026quot;, function (req, res) { url \u0026lt;- \u0026quot;https://accounts.google.com/o/oauth2/v2/auth\u0026quot; query \u0026lt;- list(client_id = \u0026quot;62291147513-pubf19de15prks9p2eij7hloteug5h5d.apps.googleusercontent.com\u0026quot;, redirect_uri = \u0026quot;http://localhost:9090/authentication/redirect\u0026quot;, scope = \u0026quot;https://www.googleapis.com/auth/userinfo.profile\u0026quot;, response_type = \u0026quot;code\u0026quot;) auth_url \u0026lt;- httr::parse_url(url = url) auth_url$query \u0026lt;- query auth_url \u0026lt;- httr::build_url(auth_url) res$status \u0026lt;- 301 res$setHeader(\u0026quot;Location\u0026quot;, auth_url) return() })  define authentication route to issue web tokens (exclude “sealr-jwt” filter using preempt) pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/authentication/redirect\u0026quot;, function (req, res, code = NULL, error = NULL) { token_url \u0026lt;- \u0026quot;https://www.googleapis.com/oauth2/v4/token\u0026quot; body \u0026lt;- list( code = code, client_id = \u0026quot;62291147513-pubf19de15prks9p2eij7hloteug5h5d.apps.googleusercontent.com\u0026quot;, client_secret = \u0026quot;0iE21iyz1htfHPtOw21zWcw6\u0026quot;, redirect_uri = \u0026quot;http://localhost:9090/authentication/redirect\u0026quot;, grant_type = \u0026quot;authorization_code\u0026quot; ) response \u0026lt;- httr::POST(token_url, body = body) parsed_response \u0026lt;- jsonlite::fromJSON(httr::content(response, type = \u0026quot;text\u0026quot;)) return(parsed_response) })  start API server pr$run(host=\u0026quot;0.0.0.0\u0026quot;, port=9090)  "
},
{
	"uri": "https://jandix.github.io/sealr/sealr/",
	"title": "sealr",
	"tags": [],
	"description": "",
	"content": "  \nThe goal of sealr is to provide multiple authentication and authorization strategies for plumber by using filters. In doing so, we hope to make best practices in authentication easy to implement for the R community. The package is inspired by the amazing passport.js library for Node.js.\nPlumber filters for authentication / authorization coming soon\nImplementation overview authenticate sealr’s main function is the authenticate function. authenticate takes a is_authed_* function (see below) as input and depending on the output of this “checker” function, takes action:\n if the request is authenticated / authorized, it forwards to the next plumber handler using plumber::forward. if the request is not authenticated / authorized, it returns to the user, passing forward HTTP status code, description and message from the output of the is_authed_ function.  By accepting a function object as argument, authenticate is quite flexible: You can even pass your own is_authed function.\nis_authed functions The functions starting with is_authed provide the actual implementations of the different authentication / authorization strategies that sealr aims to provide. Currently implemented are:\n is_authed_jwt: implements JSON Web Token verification and checking. is_authed_oauth2_google: implements Google’s OpenID Connect (which is based on OAuth2.0)  is_authed_* functions return a list with the following elements:\n is_authed: TRUE or FALSE. Result of the check whether the request is authenticated / authorized. status: character. Optional (typically only set if is_authed is FALSE). Short description of HTTP status code. code: integer. Optional (typically only set if is_authed is FALSE). HTTP status code. message: character. Optional (typically only set if is_authed is FALSE). Longer description.  Currently, the plumber package does not support imposing filters on individual endpoints (but it is on the developer team’s radar, see this issue :)). That makes it difficult to require different levels of authorization, e.g. specific authorization for specific endpoints using the plumber filter method (see jwt_claims_example).\nAs a workaround, you can put your authentication / authorization checks in the individual endpoints. The is_authed_* functions are designed so that you can use them independently from plumber filters as long as you pass a plumber request and response object.\nInstallation Currently, the package is under development. Please feel free to contribute to the package. You can install and use the package using devtools.\ndevtools::install_github(\u0026quot;jandix/sealr\u0026quot;)  Contribute We are still at the very beginning of the package and we welcome any support and contribution. Below you find a list with possible authentication strategies that you could implement. The list is not complete and can be expanded with your suggestions.\nPossible Strategies Bearer Token Sessions Twitter OAuth Facebook OAuth Google OAuth  Testing You can use curl for testing purposes. Unfortunately, curl quickly gets quite complicated if you want to add a body, parameters and unique headers. Therefore, we recommend to use Postman for larger, more complicated projects.\nExamples We provide some simple sample implementations for different strategies and use cases. You can find them in the examples folder.\nWarranity Notice THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
},
{
	"uri": "https://jandix.github.io/sealr/jwt/",
	"title": "JSON Web Tokens",
	"tags": [],
	"description": "",
	"content": "“JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.” (jwt.io)\nThe JWT stratgey allows to use JSON Web Tokens (JWT) to secure your plumber endpoints. A great introduction to JWT can be found here. JWT can be used to secure REST APIs without sessions. They are considered to be stateless.\n"
},
{
	"uri": "https://jandix.github.io/sealr/jwt/jwt_claims_example/",
	"title": "JWT Claims Example",
	"tags": [],
	"description": "",
	"content": " JSON Web Tokens (JWT) can contain claims. “Claims are statements about an entity (typically, the user) and additional data” (https://jwt.io/introduction/). They are expressed as key-value pairs.\nThere are three different types of claims: registered, public and private claims. All types of claims are implemented in the same manner, they only differ in whether and where the claims are registered with the Internet Assigned Numbers Authority (IANA). For example, the iss claim is a registered claim defined in the JWT standard RFC 7519 and registered at IANA. See the JWT Introduction of jwt.io for more details.\nsealr allows you to check for the validity of all types of claims in a given JWT using the claims argument of the sealr::is_authed_jwt function.\nIn this example implementation (see full code below), we have two filters:\nThe filter sealr-jwt simply checks whether the user is authenticated and that the issuer claim iss is set to mygreatplumberapi, the value we set in the authentication route. The second filter sealr-jwt-admin-only additionally checks whether the user is an admin by validating that the claim admin is TRUE.\n# integrate the jwt strategy in a filter pr$filter(\u0026quot;sealr-jwt\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = \u0026quot;mygreatplumberapi\u0026quot;)) }) pr$filter(\u0026quot;sealr-jwt-admin-only\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = \u0026quot;mygreatplumberapi\u0026quot;, admin = TRUE)) })  We now have two levels of access using filters: routes that are open to all authenticated users with a JWT issued by mygreatplumberapi and routes that are accessible to admins only. The former requires preempting the more restrictive sealr-jwt-admin-only filter.\nUnfortunately, it is currently not possible to extend this filter-based authorization mechanism to more than two authorization “levels” because plumber does not allow for preempting more than one filter per route. This problem is on the radar of the plumber team and they’ll provide the opportunity to impose filters on specific endpoints in the future (kind of “reverting” the preempt logic). See this plumber issue.\nRun the example Copy the code from below in a new R file and save it under jwt_claims_example.R. In the R console, run:\nplumber::plumb(\u0026quot;jwt_claims_example.R\u0026quot;)  This will make the API available at localhost:9090.\nIn order to run this example, you need the following packages installed:\n sealr plumber httr jose jsonlite  Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame).\n    id user password admin gender    1 jane@example.com $2a12s1cFAO4.cSo4pqUP4YNZxeYXv33ckcvGikvXP4QAqwu80BC5fUtM2 TRUE woman  2 bob@example.com $2a12sgP18Eb32QQk1OkURY8Dnu71yeeKNp3PgF1ZjsueUQgZ2FHRuc79m FALSE man    Get the JWT for both users:\n Jane  curl --data '{\u0026quot;user\u0026quot;: \u0026quot;jane@example.com\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;12345\u0026quot;}' localhost:9090/authentication [\u0026quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NjE0NiwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.AZqJFuXZkjwKbnULHfJVmBapFhZpBgLIUuX7HOJAUhU\u0026quot;]   Bob  curl --data '{\u0026quot;user\u0026quot;: \u0026quot;bob@example.com\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;45678\u0026quot;}' localhost:9090/authentication [\u0026quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s\u0026quot;]  Note: You might get different JWTs as we also add the time when the token was issued as a claim (iat). However, those examples should still work because we do not add an expiration time to the token - something you should definetely consider for production use cases.\nRoute with simple authentication Both users can access the /secret route because they both have valid JWT issued by mygreatplumberapi. The route preempts the more restrictive sealr-jwt-admin-only filter so even non-admin Bob has access.\n Jane  curl -H \u0026quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE\u0026quot; localhost:9090/secret [\u0026quot;Access to route that requires authentication was successful.\u0026quot;]   Bob  curl -H \u0026quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s\u0026quot; localhost:9090/secret [\u0026quot;Access to route that requires authentication was successful.\u0026quot;]  Route with admin-only authorization In contrast, only Jane can access the /secret-admin-only route.\n Jane  curl -H \u0026quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE\u0026quot; localhost:9090/secret-admin-only [\u0026quot;Access to route that requires admin authorization was successful.\u0026quot;]   Bob  curl -H \u0026quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s\u0026quot; localhost:9090/secret-admin-only {\u0026quot;status\u0026quot;:[\u0026quot;Failed.\u0026quot;],\u0026quot;code\u0026quot;:[401],\u0026quot;message\u0026quot;:[\u0026quot;Authentication required.\u0026quot;]}  Code # define a user database # you should probably use a SQL database instead of data frames users \u0026lt;- data.frame(id = integer(), name = character(), password = character(), admin = logical(), gender = character(), stringsAsFactors = FALSE) # create test user users \u0026lt;- rbind(users, data.frame(id = 1, user = \u0026quot;jane@example.com\u0026quot;, password = bcrypt::hashpw(\u0026quot;12345\u0026quot;), admin = TRUE, gender = \u0026quot;woman\u0026quot;, stringsAsFactors = FALSE)) users \u0026lt;- rbind(users, data.frame(id = 2, user = \u0026quot;bob@example.com\u0026quot;, password = bcrypt::hashpw(\u0026quot;45678\u0026quot;), admin = FALSE, gender = \u0026quot;man\u0026quot;, stringsAsFactors = FALSE)) # define a new plumber router pr \u0026lt;- plumber::plumber$new() # define your super secret secret \u0026lt;- \u0026quot;3ec9aaf4a744f833e98c954365892583\u0026quot; # integrate the jwt strategy in a filter pr$filter(\u0026quot;sealr-jwt\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = \u0026quot;mygreatplumberapi\u0026quot;)) }) # filter that checks whether the user is an admin pr$filter(\u0026quot;sealr-jwt-admin-only\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = \u0026quot;mygreatplumberapi\u0026quot;, admin = TRUE)) }) # define authentication route to issue web tokens (exclude \u0026quot;sealr-jwt\u0026quot; filter using preempt) pr$handle(\u0026quot;POST\u0026quot;, \u0026quot;/authentication\u0026quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status \u0026lt;- 404 return(list(status=\u0026quot;Failed.\u0026quot;, code=404, message=\u0026quot;Please specify password or username.\u0026quot;)) } # find user in database index \u0026lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status \u0026lt;- 401 return(list(status=\u0026quot;Failed.\u0026quot;, code=401, message=\u0026quot;User or password wrong.\u0026quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status \u0026lt;- 401 return(list(status=\u0026quot;Failed.\u0026quot;, code=401, message=\u0026quot;User or password wrong.\u0026quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload \u0026lt;- jose::jwt_claim(iss = \u0026quot;mygreatplumberapi\u0026quot;, # registered claim iat = as.numeric(Sys.time()), # registered claim admin = users$admin[index], gender = users$gender[index], # a public claim userID = users$id[index]) # private claim # convert secret to bytes secret \u0026lt;- charToRaw(secret) # encode token using the secret jwt \u0026lt;- jose::jwt_encode_hmac(payload, secret = secret) # return jwt as response return(jwt = jwt) }, preempt = c(\u0026quot;sealr-jwt\u0026quot;)) # define test route with authentication pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/secret\u0026quot;, function (req, res) { return(\u0026quot;Access to route that requires authentication was successful.\u0026quot;) }, preempt = \u0026quot;sealr-jwt-admin-only\u0026quot;) # define test route with authentication pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/secret-admin-only\u0026quot;, function (req, res) { return(\u0026quot;Access to route that requires admin authorization was successful.\u0026quot;) }) # start API server pr$run(host = \u0026quot;0.0.0.0\u0026quot;, port = 9090)  "
},
{
	"uri": "https://jandix.github.io/sealr/jwt/jwt_cookie_example/",
	"title": "JWT Cookie Example",
	"tags": [],
	"description": "",
	"content": " Instead of requiring the user to send the JWT back in the HTTP Authorization header, you can also use a cookie in the browser of the API user to store the JWT. This way, the user does not have to remember to send the JWT in the Authorization header.\nExample implementation In this example, we use an encrypted cookie to store the JWT. You can find the full code for this example at the end of this page. In order to do this, we register an encrypted session cookie (see plumber docs):\n# define a new plumber router pr \u0026lt;- plumber::plumber$new() # register cookie pr$registerHooks(plumber::sessionCookie(key = \u0026quot;EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5\u0026quot;, name = \u0026quot;token\u0026quot;))  In the authentication route, we then can set the JWT in the cookie. Note that we do not return the JWT to the user because the JWT will be transferred in the cookie instead.\npr$handle(\u0026quot;POST\u0026quot;, \u0026quot;/authentication\u0026quot;, function (req, res, user = NULL, password = NULL) { # ... # ... # set cookie req$session$token \u0026lt;- jwt return() })  The filter looks the same as in the simple example except that we have to change the token_location parameter to \u0026quot;cookie\u0026quot; instead of \u0026quot;header\u0026quot;.\n# integrate the jwt strategy in a filter pr$filter(\u0026quot;sealr-jwt\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response # please change the secret sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = \u0026quot;cookie\u0026quot;, secret = secret) })  :warning: Please change the secret to a super secure secret of your choice. Please notice that you have to preempt = c(\u0026quot;sealr-jwt\u0026quot;) to routes that should not be protected.\nRun the example Copy the code from below in a new R file and save it under jwt_cookie_example.R. In the R console, run:\nplumber::plumb(\u0026quot;jwt_cookie_example.R\u0026quot;)  In order to run this example, you need the following packages installed:\n sealr plumber httr jose jsonlite  Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame).\n    id user password    1 jane@example.com $2a12rj8TddYRy6fPXxbfBZjovO5DdLxm5jVhWCdz5un2Wi6v47YSKc2oe  2 bob@example.com $2a12toswpnhB3L5IOzd4JWs4MefiBx5OxVQNJ5cMg/aFohM.blHRHttNm    For example, in curl:\nNote: You might get different encrypted JWTs in your cookies_jane.txt as jose::jwt_encode_hmac automatically adds the time when the JWT was issued as a claim (iat claim).\ncurl --cookie-jar cookies_jane.txt --data '{\u0026quot;user\u0026quot;: \u0026quot;jane@example.com\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;12345\u0026quot;}' localhost:9090/authentication  The --cookie-jar argument will store the cookie in a plain-text file in your current directory called cookies_jane.txt.\nIf you inspect this file (e.g. using cat cookies_jane.txt), you should see something like this:\n# Netscape HTTP Cookie File # https://curl.haxx.se/docs/http-cookies.html # This file was generated by libcurl! Edit at your own risk. localhost FALSE / FALSE 0 token R/cOKStnaCrwojcbL4Uk1602scv7ln9PClDYO2LlfHd0zYtd+vYrGB6oTX7wvpp5hmipFxqnQ0FDwEdz1H7IjCr6KCxxUHnpWu8r0IjCA4zLHbJz/i5npGe16Ei+OhbOGbluT/An+0GnfzXsna4q4vHoB2P+GkUPZL3Xe7tZxIX+UHSk005tX89NcSLpVy6J  The token is the gibberish part at the end. It is indeed the JWT but it is encrypted and hence does not look like a JWT.\nTrying to get a token cookie for a user that is not in the database of course fails:\ncurl --cookie-jar cookies_drake.txt --data '{\u0026quot;user\u0026quot;: \u0026quot;drake@example.com\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;10111213\u0026quot;}' localhost:9090/authentication {\u0026quot;status\u0026quot;:[\u0026quot;Failed.\u0026quot;],\u0026quot;code\u0026quot;:[401],\u0026quot;message\u0026quot;:[\u0026quot;User or password wrong.\u0026quot;]}  Route without required authentication Everyone can access the / route because it does not require authentication - the sealr-jwt filter is preempted for this route:\ncurl localhost:9090 [\u0026quot;Access to route without authentication was successful.\u0026quot;]  Route with required authentication Trying to access the /secret route without a valid cookie fails because it goes through the sealr-jwt filter where the sealr::jwt function will check for the correct authentication details - in this case a valid JWT in token cookie.\ncurl localhost:9090/secret {\u0026quot;status\u0026quot;:[\u0026quot;Failed.\u0026quot;],\u0026quot;code\u0026quot;:[401],\u0026quot;message\u0026quot;:[\u0026quot;Authentication required.\u0026quot;]}  But if you add the cookies for Jane to the request, authentication is successful.\ncurl --cookie cookies_jane.txt localhost:9090/secret [\u0026quot;Access to route requiring authentication was successful.\u0026quot;]  Code {code} # define a user database # you should probably use a SQL database instead of data frames users \u0026lt;- data.frame(id = integer(), name = character(), password = character(), stringsAsFactors = FALSE) # create test user users \u0026lt;- rbind(users, data.frame(id = 1, user = \u0026quot;jane@example.com\u0026quot;, password = bcrypt::hashpw(\u0026quot;12345\u0026quot;), stringsAsFactors = FALSE)) users \u0026lt;- rbind(users, data.frame(id = 2, user = \u0026quot;bob@example.com\u0026quot;, password = bcrypt::hashpw(\u0026quot;45678\u0026quot;), stringsAsFactors = FALSE)) # define a new plumber router pr \u0026lt;- plumber::plumber$new() # register cookie pr$registerHooks(plumber::sessionCookie(key = \u0026quot;EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5\u0026quot;, name = \u0026quot;token\u0026quot;)) # define your super secret for hmac secret \u0026lt;- \u0026quot;3ec9aaf4a744f833e98c954365892583\u0026quot; # integrate the jwt strategy in a filter pr$filter(\u0026quot;sealr-jwt\u0026quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = \u0026quot;cookie\u0026quot;, secret = secret) }) # define authentication route to issue web tokens (exclude \u0026quot;sealr-jwt\u0026quot; filter using preempt) pr$handle(\u0026quot;POST\u0026quot;, \u0026quot;/authentication\u0026quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status \u0026lt;- 404 return(list(status=\u0026quot;Failed.\u0026quot;, code=404, message=\u0026quot;Please return password or username.\u0026quot;)) } # find user in database index \u0026lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status \u0026lt;- 401 return(list(status=\u0026quot;Failed.\u0026quot;, code=401, message=\u0026quot;User or password wrong.\u0026quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status \u0026lt;- 401 return(list(status=\u0026quot;Failed.\u0026quot;, code=401, message=\u0026quot;User or password wrong.\u0026quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload \u0026lt;- jose::jwt_claim(userID = users$id[index]) # convert secret to bytes secret_raw \u0026lt;- charToRaw(secret) # encode token using the secret jwt \u0026lt;- jose::jwt_encode_hmac(payload, secret = secret_raw) # set cookie req$session$token \u0026lt;- jwt return() }, preempt = c(\u0026quot;sealr-jwt\u0026quot;)) # define test route without authentication (exclude \u0026quot;sealr-jwt\u0026quot; filter using preempt) pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/\u0026quot;, function (req, res) { return(\u0026quot;Access to route without authentication was successful.\u0026quot;) }, preempt = c(\u0026quot;sealr-jwt\u0026quot;)) # define test route with authentication pr$handle(\u0026quot;GET\u0026quot;, \u0026quot;/secret\u0026quot;, function (req, res) { return(\u0026quot;Access to route requiring authentication was successful.\u0026quot;) }) # start API server pr$run(host = \u0026quot;0.0.0.0\u0026quot;, port = 9090)  "
},
{
	"uri": "https://jandix.github.io/sealr/oauth_google/",
	"title": "OAuth2 Google",
	"tags": [],
	"description": "",
	"content": "OpenID Connect coming soon\n"
},
{
	"uri": "https://jandix.github.io/sealr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jandix.github.io/sealr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://jandix.github.io/sealr/",
	"title": "sealr",
	"tags": [],
	"description": "",
	"content": ""
}]