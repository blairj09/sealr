% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is_authed_jwt.R
\name{is_authed_jwt}
\alias{is_authed_jwt}
\title{JWT Strategy}
\usage{
is_authed_jwt(req, res, token_location, secret = NULL, pubkey = NULL,
  claims = NULL)
}
\arguments{
\item{req}{Request object.}

\item{res}{Response object.}

\item{token_location}{character. Location of JWT. Either "header" or "cookie".
See \code{\link{get_token_from_req}} for details.}

\item{secret}{character. The secret that was used to sign your JWT. The secret is converted
to raw bytes in the function. Default NULL.}

\item{pubkey}{character. Public RSA or ECDSA key that was used to generate the JWT. Default NULL.}

\item{claims}{named list. Claims that should be checked in the JWT. Default NULL.}
}
\value{
list with the following elements:
\itemize{
  \item is_authed: TRUE or FALSE. Result of the check whether the JWT is valid.
  \item status: character. Optional. Short description of HTTP status code.
  \item code: integer. Optional. HTTP status code.
  \item message: character. Optional. Longer description.
}
}
\description{
\code{is_authed_jwt} checks whether a JWT passed as part of the HTTP request is valid.
The function can be passed to \code{\link{authenticate}}'s \code{is_authed_fun}
argument or it can be used standalone in any plumber endpoint.
\code{is_authed_jwt} extracts the token from the HTTP Authorization header with the scheme 'bearer'.
}
\examples{
\dontrun{
 pr$filter("sealr-jwt-filter", function(req, res){ # usage in a filter
   sealr::authenticate(req = req, res = res, sealr::is_authed_jwt, secret = "averylongsupersecretsecret")
 })
}

\dontrun{
 pr$handle("GET", "/somedata", function(req, res){ # usage in an endpoint
   is_authed_list <- sealr::is_authed_jwt(req, res, secret = "averylongsupersecretsecret",
                                     claims = list(iss = "myplumberapi"))
   if (is_authed_list$is_authed){
     return("somedata")
   } else {
     # return error or do something else
     is_authed_list$is_authed <- NULL
     return(is_authed_list)
   }
 })
}
}
