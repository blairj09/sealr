[
["01_intro.html", "1 sealr 1.1 Authentication and Authorization 1.2 Using plumber filters for auth", " 1 sealr 1.1 Authentication and Authorization TODO 1.2 Using plumber filters for auth The primary logic of sealr is based on plumber filters (although you can use sealr functionality without filters as well by using the is_authed functions directly, see below). “Plumber filters can be used to define a “pipeline” for handling incoming requests\" (Plumber docs). So if your plumber API receives a request, the request will first be routed through the different filters before it “arrives” at its destination endpoint. The idea of sealr is to use a filter for authentication. If a request is not properly authenticated / authorized, sealr will immediately return a “401 - Authentication failed.” error from the filter to the user. In this way, an unauthenticated / unauthorized request will not “reach” its destination endpoint. 1.2.1 authenticate sealr’s main function is the authenticate function. It is supposed to be used within a plumber filter. authenticate takes a is_authed_* function (see below) as input and depending on the output of this “checker” function, takes action: if the request is authenticated / authorized, it forwards to the next plumber handler using plumber::forward. if the request is not authenticated / authorized, it returns to the user, passing forward HTTP status code, description and message from the output of the is_authed_ function. Most often, this will be a “401 - Authentication failed.” error. By accepting a function object as argument, authenticate is quite flexible: You can even pass your own is_authed function. See the examples section of ?sealr::authenticate for a simple example. 1.2.2 is_authed functions The functions starting with is_authed provide the actual implementations of the different authentication / authorization strategies that sealr aims to provide. Currently implemented are: is_authed_jwt: implements JSON Web Token verification and checking. is_authed_oauth2_google: implements Google’s OpenID Connect (which is based on OAuth2.0) is_authed_* functions return a list with the following elements: is_authed: TRUE or FALSE. Result of the check whether the request is authenticated / authorized. status: character. Optional (typically only set if is_authed is FALSE). Short description of HTTP status code. code: integer. Optional (typically only set if is_authed is FALSE). HTTP status code. message: character. Optional (typically only set if is_authed is FALSE). Longer description. Usage of the is_authed functions is not restricted to plumber filters. For example, you can use an is_authed function at the top of an endpoint to restrict access to certain endpoints or use different authorization “levels” for different endpoints. This is particularly relevant if you have more than two “levels” of authorization (see the claims example). "],
["02_auth_providers.html", "2 Implementing Authentication and Authorization 2.1 Authentication 2.2 Authorization 2.3 JSON Web Tokens (JWT)", " 2 Implementing Authentication and Authorization 2.1 Authentication 2.1.1 Custom 2.1.2 Third party 2.2 Authorization 2.3 JSON Web Tokens (JWT) “JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.” (jwt.io) The JWT stratgey allows to use JSON Web Tokens (JWT) to secure your plumber endpoints. A great introduction to JWT can be found here. JWT can be used to secure REST APIs without sessions. They are considered to be stateless although they can also be used as stateful session tokens. JSON Web Tokens (JWT) can contain claims. “Claims are statements about an entity (typically, the user) and additional data” (https://jwt.io/introduction/). They are expressed as key-value pairs. There are three different types of claims: registered, public and private claims. All types of claims are implemented in the same manner, they only differ in whether and where the claims are registered with the Internet Assigned Numbers Authority (IANA). For example, the iss claim is a registered claim defined in the JWT standard RFC 7519 and registered at IANA. See the JWT Introduction of jwt.io for more details. sealr allows you to check for the validity of all types of claims in a given JWT using the claims argument of the sealr::is_authed_jwt function. "],
["03_storage.html", "3 Storage of Tokens 3.1 Cookie", " 3 Storage of Tokens 3.1 Cookie Instead of requiring the user to send the JWT back in the HTTP Authorization header, you can also use a cookie in the browser of the API user to store the JWT. This way, the user does not have to remember to send the JWT in the Authorization header. "],
["04_examples.html", "4 Examples 4.1 JWT Simple Example 4.2 Cookie Example 4.3 JWT Claims Example", " 4 Examples 4.1 JWT Simple Example 4.2 Cookie Example In this example, we use an encrypted cookie to store the JWT. You can find the full code for this example at the end of this page. In order to do this, we register an encrypted session cookie (see plumber docs): # define a new plumber router pr &lt;- plumber::plumber$new() # register cookie pr$registerHooks(plumber::sessionCookie(key = &quot;EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5&quot;, name = &quot;token&quot;)) In the authentication route, we then can set the JWT in the cookie. Note that we do not return the JWT to the user because the JWT will be transferred in the cookie instead. pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # ... # ... # set cookie req$session$token &lt;- jwt return() }) The filter looks the same as in the simple example except that we have to change the token_location parameter to \"cookie\" instead of \"header\". # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response # please change the secret sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;cookie&quot;, secret = secret) }) :warning: Please change the secret to a super secure secret of your choice. Please notice that you have to preempt = c(\"sealr-jwt\") to routes that should not be protected. 4.2.1 Run the example Copy the code from below in a new R file and save it under jwt_cookie_example.R. In the R console, run: plumber::plumb(&quot;jwt_cookie_example.R&quot;) In order to run this example, you need the following packages installed: sealr plumber httr jose jsonlite 4.2.1.1 Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame). id user password 1 jane@example.com $2a\\(12\\)WXQ1xlYXNJqNSWZF7XMlT.a7Qy6zSmcsC5ov.XywmEqbD7ywGSlfa 2 bob@example.com $2a\\(12\\)/0o5/PQiZwIZSL1RzVskWeUa9oCS/CGRQzBzuWbN/yhu4pz96vah6 For example, in curl: Note: You might get different encrypted JWTs in your cookies_jane.txt as jose::jwt_encode_hmac automatically adds the time when the JWT was issued as a claim (iat claim). curl --cookie-jar cookies_jane.txt --data &#39;{&quot;user&quot;: &quot;jane@example.com&quot;, &quot;password&quot;: &quot;12345&quot;}&#39; localhost:9090/authentication The --cookie-jar argument will store the cookie in a plain-text file in your current directory called cookies_jane.txt. If you inspect this file (e.g. using cat cookies_jane.txt), you should see something like this: # Netscape HTTP Cookie File # https://curl.haxx.se/docs/http-cookies.html # This file was generated by libcurl! Edit at your own risk. localhost FALSE / FALSE 0 token R/cOKStnaCrwojcbL4Uk1602scv7ln9PClDYO2LlfHd0zYtd+vYrGB6oTX7wvpp5hmipFxqnQ0FDwEdz1H7IjCr6KCxxUHnpWu8r0IjCA4zLHbJz/i5npGe16Ei+OhbOGbluT/An+0GnfzXsna4q4vHoB2P+GkUPZL3Xe7tZxIX+UHSk005tX89NcSLpVy6J The token is the gibberish part at the end. It is indeed the JWT but it is encrypted and hence does not look like a JWT. Trying to get a token cookie for a user that is not in the database of course fails: curl --cookie-jar cookies_drake.txt --data &#39;{&quot;user&quot;: &quot;drake@example.com&quot;, &quot;password&quot;: &quot;10111213&quot;}&#39; localhost:9090/authentication {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;User or password wrong.&quot;]} 4.2.2 Route without required authentication Everyone can access the / route because it does not require authentication - the sealr-jwt filter is preempted for this route: curl localhost:9090 [&quot;Access to route without authentication was successful.&quot;] 4.2.3 Route with required authentication Trying to access the /secret route without a valid cookie fails because it goes through the sealr-jwt filter where the sealr::jwt function will check for the correct authentication details - in this case a valid JWT in token cookie. curl localhost:9090/secret {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;Authentication required.&quot;]} But if you add the cookies for Jane to the request, authentication is successful. curl --cookie cookies_jane.txt localhost:9090/secret [&quot;Access to route requiring authentication was successful.&quot;] 4.2.4 Code {code} # define a user database # you should probably use a SQL database instead of data frames users &lt;- data.frame(id = integer(), name = character(), password = character(), stringsAsFactors = FALSE) # create test user users &lt;- rbind(users, data.frame(id = 1, user = &quot;jane@example.com&quot;, password = bcrypt::hashpw(&quot;12345&quot;), stringsAsFactors = FALSE)) users &lt;- rbind(users, data.frame(id = 2, user = &quot;bob@example.com&quot;, password = bcrypt::hashpw(&quot;45678&quot;), stringsAsFactors = FALSE)) # define a new plumber router pr &lt;- plumber::plumber$new() # register cookie pr$registerHooks(plumber::sessionCookie(key = &quot;EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5&quot;, name = &quot;token&quot;)) # define your super secret for hmac secret &lt;- &quot;3ec9aaf4a744f833e98c954365892583&quot; # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt, token_location = &quot;cookie&quot;, secret = secret) }) # define authentication route to issue web tokens (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status &lt;- 404 return(list(status=&quot;Failed.&quot;, code=404, message=&quot;Please return password or username.&quot;)) } # find user in database index &lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload &lt;- jose::jwt_claim(userID = users$id[index]) # convert secret to bytes secret_raw &lt;- charToRaw(secret) # encode token using the secret jwt &lt;- jose::jwt_encode_hmac(payload, secret = secret_raw) # set cookie req$session$token &lt;- jwt return() }, preempt = c(&quot;sealr-jwt&quot;)) # define test route without authentication (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;GET&quot;, &quot;/&quot;, function (req, res) { return(&quot;Access to route without authentication was successful.&quot;) }, preempt = c(&quot;sealr-jwt&quot;)) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret&quot;, function (req, res) { return(&quot;Access to route requiring authentication was successful.&quot;) }) # start API server pr$run(host = &quot;0.0.0.0&quot;, port = 9090) 4.3 JWT Claims Example In this example implementation (see full code below), we have two filters: The filter sealr-jwt simply checks whether the user is authenticated and that the issuer claim iss is set to mygreatplumberapi, the value we set in the authentication route. The second filter sealr-jwt-admin-only additionally checks whether the user is an admin by validating that the claim admin is TRUE. # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;)) }) pr$filter(&quot;sealr-jwt-admin-only&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;, admin = TRUE)) }) We now have two levels of access using filters: routes that are open to all authenticated users with a JWT issued by mygreatplumberapi and routes that are accessible to admins only. The former requires preempting the more restrictive sealr-jwt-admin-only filter. Unfortunately, it is currently not possible to extend this filter-based authorization mechanism to more than two authorization “levels” because plumber does not allow for preempting more than one filter per route. This problem is on the radar of the plumber team and they’ll provide the opportunity to impose filters on specific endpoints in the future (kind of “reverting” the preempt logic). See this plumber issue. As a workaround, you could put your authentication / authorization checks in the individual endpoints. In this case, use is_authed_* functions instead of the authenticate wrapper. 4.3.1 Run the example Copy the code from below in a new R file and save it under jwt_claims_example.R. In the R console, run: plumber::plumb(&quot;jwt_claims_example.R&quot;) This will make the API available at localhost:9090. In order to run this example, you need the following packages installed: sealr plumber httr jose jsonlite 4.3.1.1 Get authentication Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API’s “database” (in this simplified example, a data frame). id user password admin gender 1 jane@example.com $2a\\(12\\)gya9SPsvOzq0luPJFhdzteuWqlS8NNAz.iW8dzZ7v9LiWaPAC3qcq TRUE woman 2 bob@example.com $2a\\(12\\)oUzNoxR4Ye4CdYZ42BxBluExXaJc49UcgDLBtZwuNWrx6nh10MvHO FALSE man Get the JWT for both users: Jane curl --data &#39;{&quot;user&quot;: &quot;jane@example.com&quot;, &quot;password&quot;: &quot;12345&quot;}&#39; localhost:9090/authentication [&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NjE0NiwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.AZqJFuXZkjwKbnULHfJVmBapFhZpBgLIUuX7HOJAUhU&quot;] Bob curl --data &#39;{&quot;user&quot;: &quot;bob@example.com&quot;, &quot;password&quot;: &quot;45678&quot;}&#39; localhost:9090/authentication [&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s&quot;] Note: You might get different JWTs as we also add the time when the token was issued as a claim (iat). However, those examples should still work because we do not add an expiration time to the token - something you should definetely consider for production use cases. 4.3.1.2 Route with simple authentication Both users can access the /secret route because they both have valid JWT issued by mygreatplumberapi. The route preempts the more restrictive sealr-jwt-admin-only filter so even non-admin Bob has access. Jane curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE&quot; localhost:9090/secret [&quot;Access to route that requires authentication was successful.&quot;] Bob curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s&quot; localhost:9090/secret [&quot;Access to route that requires authentication was successful.&quot;] 4.3.1.3 Route with admin-only authorization In contrast, only Jane can access the /secret-admin-only route. Jane curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE&quot; localhost:9090/secret-admin-only [&quot;Access to route that requires admin authorization was successful.&quot;] Bob curl -H &quot;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s&quot; localhost:9090/secret-admin-only {&quot;status&quot;:[&quot;Failed.&quot;],&quot;code&quot;:[401],&quot;message&quot;:[&quot;Authentication required.&quot;]} 4.3.2 Code # define a user database # you should probably use a SQL database instead of data frames users &lt;- data.frame(id = integer(), name = character(), password = character(), admin = logical(), gender = character(), stringsAsFactors = FALSE) # create test user users &lt;- rbind(users, data.frame(id = 1, user = &quot;jane@example.com&quot;, password = bcrypt::hashpw(&quot;12345&quot;), admin = TRUE, gender = &quot;woman&quot;, stringsAsFactors = FALSE)) users &lt;- rbind(users, data.frame(id = 2, user = &quot;bob@example.com&quot;, password = bcrypt::hashpw(&quot;45678&quot;), admin = FALSE, gender = &quot;man&quot;, stringsAsFactors = FALSE)) # define a new plumber router pr &lt;- plumber::plumber$new() # define your super secret secret &lt;- &quot;3ec9aaf4a744f833e98c954365892583&quot; # integrate the jwt strategy in a filter pr$filter(&quot;sealr-jwt&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;)) }) # filter that checks whether the user is an admin pr$filter(&quot;sealr-jwt-admin-only&quot;, function (req, res) { # simply call the strategy and forward the request and response sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret, claims = list(iss = &quot;mygreatplumberapi&quot;, admin = TRUE)) }) # define authentication route to issue web tokens (exclude &quot;sealr-jwt&quot; filter using preempt) pr$handle(&quot;POST&quot;, &quot;/authentication&quot;, function (req, res, user = NULL, password = NULL) { # check if user provided credentials if (is.null(user) || is.null(password)) { res$status &lt;- 404 return(list(status=&quot;Failed.&quot;, code=404, message=&quot;Please specify password or username.&quot;)) } # find user in database index &lt;- match(user, users$user) # check if user exist if (is.na(index)) { res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # check if password is correct if (!bcrypt::checkpw(password, users$password[index])){ res$status &lt;- 401 return(list(status=&quot;Failed.&quot;, code=401, message=&quot;User or password wrong.&quot;)) } # define jwt payload # information about the additional fields can be found at # https://tools.ietf.org/html/rfc7519#section-4.1 payload &lt;- jose::jwt_claim(iss = &quot;mygreatplumberapi&quot;, # registered claim iat = as.numeric(Sys.time()), # registered claim admin = users$admin[index], gender = users$gender[index], # a public claim userID = users$id[index]) # private claim # convert secret to bytes secret &lt;- charToRaw(secret) # encode token using the secret jwt &lt;- jose::jwt_encode_hmac(payload, secret = secret) # return jwt as response return(jwt = jwt) }, preempt = c(&quot;sealr-jwt&quot;)) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret&quot;, function (req, res) { return(&quot;Access to route that requires authentication was successful.&quot;) }, preempt = &quot;sealr-jwt-admin-only&quot;) # define test route with authentication pr$handle(&quot;GET&quot;, &quot;/secret-admin-only&quot;, function (req, res) { return(&quot;Access to route that requires admin authorization was successful.&quot;) }) # start API server pr$run(host = &quot;0.0.0.0&quot;, port = 9090) "],
["05_security.html", "5 Security 5.1 R Markdown 5.2 Including Plots", " 5 Security 5.1 R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 5.2 Including Plots You can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. "]
]
