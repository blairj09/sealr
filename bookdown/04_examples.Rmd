
# Examples 
## JWT Simple Example

## Cookie Example
In this example, we use an encrypted cookie to store the JWT. You can find the 
full code for this example at the [end of this page](#code). 
In order to do this, we register an encrypted session cookie ([see plumber docs](https://www.rplumber.io/docs/rendering-and-output.html#encrypted-cookies)):

```{r register_cookie, eval = FALSE}
# define a new plumber router
pr <- plumber::plumber$new()
# register cookie
pr$registerHooks(plumber::sessionCookie(key = "EPCGoaMO9dIxIEPoOjOL4sjL4U6w0GQ5", name = "token"))
```

In the `authentication` route, we then can set the JWT in the cookie.
Note that we do not return the JWT to the user because the JWT will be transferred in the cookie instead.

```{r set_cookie, eval = FALSE}
pr$handle("POST", "/authentication", function (req, res, user = NULL, password = NULL) {
  # ...
  # ...
  # set cookie
  req$session$token <- jwt
  return()
})
```

The filter looks the same as in the simple example except that we have to change the `token_location` parameter to `"cookie"` instead of `"header"`. 

```{r jwt_strategy, eval=FALSE}
# integrate the jwt strategy in a filter
pr$filter("sealr-jwt", function (req, res) {
  # simply call the strategy and forward the request and response
  # please change the secret
  sealr::authenticate(req = req, res = res, is_authed_fun = sealr::is_authed_jwt,
                      token_location = "cookie", secret = secret)
})
```

:warning: Please change the secret to a super secure secret of your choice. Please notice that you have to `preempt = c("sealr-jwt")` to routes that should **not** be protected.

### Run the example
Copy the code from [below](#code) in a new R file and 
save it under `jwt_cookie_example.R`. In the R console, run:

```{r eval = FALSE}
plumber::plumb("jwt_cookie_example.R")
```

In order to run this example, you need the following packages installed: 

- sealr
- plumber
- httr
- jose
- jsonlite


#### Get authentication 

Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API's "database" (in this simplified example, a data frame).


```{r echo=FALSE}
users <- data.frame(id       = integer(),
                    name     = character(),
                    password = character(),
                    stringsAsFactors = FALSE)

# create test user
users <- rbind(users, data.frame(id       = 1,
                                 user     = "jane@example.com",
                                 password = bcrypt::hashpw("12345"),
                                 stringsAsFactors = FALSE))
users <- rbind(users, data.frame(id       = 2,
                                 user     = "bob@example.com",
                                 password = bcrypt::hashpw("45678"),
                                 stringsAsFactors = FALSE))
kableExtra::kable(users, format = "markdown")
```

For example, in curl: 

**Note**: You might get different encrypted JWTs in your `cookies_jane.txt` as `jose::jwt_encode_hmac` automatically adds the time when the JWT was issued as a claim (`iat` claim). 

```
curl  --cookie-jar cookies_jane.txt --data '{"user": "jane@example.com", "password": "12345"}' localhost:9090/authentication
```

The `--cookie-jar` argument will store the cookie in a plain-text file in your current directory called `cookies_jane.txt`.

If you inspect this file (e.g. using `cat cookies_jane.txt`), you should see something like this: 

```
# Netscape HTTP Cookie File
# https://curl.haxx.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

localhost	FALSE	/	FALSE	0	token	R/cOKStnaCrwojcbL4Uk1602scv7ln9PClDYO2LlfHd0zYtd+vYrGB6oTX7wvpp5hmipFxqnQ0FDwEdz1H7IjCr6KCxxUHnpWu8r0IjCA4zLHbJz/i5npGe16Ei+OhbOGbluT/An+0GnfzXsna4q4vHoB2P+GkUPZL3Xe7tZxIX+UHSk005tX89NcSLpVy6J
```

The token is the gibberish part at the end. It is indeed the JWT but it is encrypted and hence does not *look* like a JWT. 

Trying to get a token cookie for a user that is not in the database of course fails: 

```
curl --cookie-jar cookies_drake.txt --data '{"user": "drake@example.com", "password": "10111213"}' localhost:9090/authentication
```

```
{"status":["Failed."],"code":[401],"message":["User or password wrong."]}
```

### Route without required authentication 

Everyone can access the `/` route because it does not require authentication - the `sealr-jwt` filter is `preempt`ed for this route:
```
curl localhost:9090
["Access to route without authentication was successful."]
```

### Route with required authentication 

Trying to access the `/secret` route without a valid cookie fails because it goes through the `sealr-jwt` filter where the `sealr::jwt` function will check for the correct authentication details - in this case a valid JWT in `token` cookie. 

```
curl localhost:9090/secret
```

```
{"status":["Failed."],"code":[401],"message":["Authentication required."]}
```

But if you add the cookies for Jane to the request, authentication is successful.

```
curl --cookie cookies_jane.txt localhost:9090/secret
```

```
["Access to route requiring authentication was successful."]
```


### Code {code}
```{r full_code, code=readLines("examples/jwt_cookie_example.R"), eval=FALSE}

```



## JWT Claims Example 

In this example implementation (see full code [below](#code)), we have two filters:

The filter `sealr-jwt` simply checks whether the user is authenticated and that the issuer claim `iss` is set to `mygreatplumberapi`, the value we set in the `authentication` route.
The second filter  `sealr-jwt-admin-only` additionally checks whether the user is an admin by validating that the claim `admin` is `TRUE`. 

```{r eval=FALSE}
# integrate the jwt strategy in a filter
pr$filter("sealr-jwt", function (req, res) {
  # simply call the strategy and forward the request and response
  sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret,
             claims = list(iss = "mygreatplumberapi"))
})

pr$filter("sealr-jwt-admin-only", function (req, res) {
  # simply call the strategy and forward the request and response
  sealr::authenticate(req = req, res = res, is_authed_fun = is_authed_jwt, secret = secret,
             claims = list(iss = "mygreatplumberapi", admin = TRUE))
})

```


We now have two levels of access using filters: routes that are open to all authenticated users with a JWT issued by `mygreatplumberapi` and routes that are accessible to admins only. The former requires `preempt`ing the more restrictive `sealr-jwt-admin-only` filter. 

Unfortunately, it is currently not possible to extend this filter-based authorization mechanism to more than two authorization "levels" because `plumber` does not allow for preempting more than one filter per route. 
This problem is on the radar of the `plumber` team and they'll provide the opportunity to impose filters on specific
endpoints in the future (kind of "reverting" the `preempt` logic). See [this plumber issue](https://github.com/trestletech/plumber/issues/108).

As a workaround, you could put your authentication / authorization checks in the individual endpoints.
In this case, use `is_authed_*` functions instead of the `authenticate` wrapper.

### Run the example
Copy the code from [below](#code) in a new R file and 
save it under `jwt_claims_example.R`. In the R console, run:

```{r eval = FALSE}
plumber::plumb("jwt_claims_example.R")
```

This will make the API available at `localhost:9090`.

In order to run this example, you need the following packages installed: 

- sealr
- plumber
- httr
- jose
- jsonlite


#### Get authentication

Using curl, Postman or a similar tool for sending HTTP requests, send a POST request with the details of one of the two users that are in the API's "database" (in this simplified example, a data frame).


```{r echo=FALSE}
# define a user database
# you should probably use a SQL database instead of data frames
users <- data.frame(id       = integer(),
                    name     = character(),
                    password = character(),
                    admin = logical(),
                    gender = character(),
                    stringsAsFactors = FALSE)

# create test user
users <- rbind(users, data.frame(id       = 1,
                                 user     = "jane@example.com",
                                 password = bcrypt::hashpw("12345"),
                                 admin = TRUE,
                                 gender = "woman",
                                 stringsAsFactors = FALSE))
users <- rbind(users, data.frame(id       = 2,
                                 user     = "bob@example.com",
                                 password = bcrypt::hashpw("45678"),
                                 admin = FALSE,
                                 gender = "man",
                                 stringsAsFactors = FALSE))

kableExtra::kable(users, format = "markdown")
```

Get the JWT for both users: 

- Jane 

```
curl --data '{"user": "jane@example.com", "password": "12345"}' localhost:9090/authentication
["eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NjE0NiwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.AZqJFuXZkjwKbnULHfJVmBapFhZpBgLIUuX7HOJAUhU"]
```

- Bob 

```
curl --data '{"user": "bob@example.com", "password": "45678"}' localhost:9090/authentication
["eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s"]
```

**Note**: You might get different JWTs as we also add the time when the token was issued as a claim (`iat`). However, those examples should still work because we do not add an expiration time to the token -  something you should definetely consider for production use cases.  

#### Route with simple authentication

Both users can access the `/secret` route because they both have valid JWT issued by `mygreatplumberapi`. The route `preempt`s the more restrictive `sealr-jwt-admin-only` filter so even non-admin Bob has access.

- Jane
```
curl -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE" localhost:9090/secret

["Access to route that requires authentication was successful."]
```

- Bob
```
curl -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s" localhost:9090/secret

["Access to route that requires authentication was successful."]
```

#### Route with admin-only authorization


In contrast, only Jane can access the `/secret-admin-only` route.

- Jane
```
curl -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTc3NSwiYWRtaW4iOnRydWUsImdlbmRlciI6IndvbWFuIiwidXNlcklEIjoxfQ.FXLTGUcsn8yuiS7VqoGEjw94zQsmO6sYdWJeLeS-PhE" localhost:9090/secret-admin-only

["Access to route that requires admin authorization was successful."]
```

- Bob 
```
curl -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJteWdyZWF0cGx1bWJlcmFwaSIsImlhdCI6MTU1MzY3NTgzNCwiYWRtaW4iOmZhbHNlLCJnZW5kZXIiOiJtYW4iLCJ1c2VySUQiOjJ9.WjRD5aIaqgApWJ-bf0VosbMZ3ovDyvRVvYug-5egL8s" localhost:9090/secret-admin-only

{"status":["Failed."],"code":[401],"message":["Authentication required."]}
```

### Code {#code}

```{r, code = readLines("examples/jwt_claims_example.R"), eval = FALSE}

```


